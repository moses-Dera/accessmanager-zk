# Threat Model & Security Analysis

## Security Guarantees

| Property | Guaranteed? | How |
|----------|-------------|-----|
| Role membership privacy | ✅ | Only Merkle root stored on-chain; no wallet addresses |
| Replay attack prevention | ✅ | Nullifiers tracked on-chain; each proof usable exactly once |
| Cross-action replay prevention | ✅ | `nullifier = hash(secret, action_hash)` binds proof to specific action |
| Proof soundness | ✅ (relies on Noir/Barretenberg) | ZK proof system is computationally sound |
| Frontrunning resistance | ✅ (partial) | Proof outcome is predetermined — relayer cannot alter the action |

---

## Threats Mitigated

### 1. Public Identity Leakage

**Threat:** Observer monitors which wallets call a privileged function (e.g., DAO withdrawal) and builds a dossier of authorized members.

**Mitigation:** No wallet-to-role mapping is stored. The proof is valid regardless of which address submits it — a relayer or fresh wallet can submit on behalf of the user. On-chain data only shows *someone with the role* acted.

---

### 2. Replay Attacks

**Threat:** Attacker records a valid proof for "Withdraw 500" and resubmits it to drain the treasury.

**Mitigation:** The circuit enforces `nullifier = hash(secret, action_hash)`. After first use, the smart contract stores `nullifiers[nullifier] = true`. Any re-submission reverts with `Nullifier already used`.

---

### 3. Cross-Action Replay

**Threat:** A proof generated for "Action A" (e.g., vote on proposal #1) is reused for "Action B" (e.g., vote on proposal #2).

**Mitigation:** `action_hash` is a public input and the contract verifies `assert(public_inputs[1] == action)`. To reuse a proof for a different action, the user would need to forge a proof with a different `action_hash`, which is computationally infeasible.

---

### 4. Frontrunning / Griefing

**Threat:** A relayer sees a pending transaction and submits the same proof first.

**Mitigation:** The proof's outcome is fixed — if the attacker submits the proof, the action executes as the user intended (e.g., the withdrawal still happens). If `action_hash` encodes a recipient or specific parameters, the relayer cannot change the outcome. **Result: griefing is economically irrational.**

---

## Residual Risks & Mitigations

### Gas-paying wallet links identity

Even if authorization is anonymous, if the user pays gas from a known wallet, their identity may be inferred.  
**Recommendation:** Use Starknet Account Abstraction with a paymaster or submit via an anonymous relayer service.

### Compromised user secret

If a user's secret is stolen, the attacker can generate valid proofs indefinitely until the Merkle root is rotated.  
**Recommendation:** Implement secret revocation via root rotation (add a root update mechanism with a governance delay).

### Malicious root governance

The entity controlling `setup_role_root` can insert their own secrets and authorize any action.  
**Recommendation:** Gate `setup_role_root` through a DAO timelock or multisig to prevent unilateral root manipulation.

### MockVerifier in demo

The demo uses `MockVerifier` which accepts any non-empty proof. In production, this **must** be replaced with the Groth16/Honk verifier generated by `nargo codegen-verifier`.

---

## Upgrade Path to Production Verifier

```bash
cd circuits

# 1. Generate the Cairo verifier from the compiled circuit
nargo codegen-verifier

# 2. Copy the output to contracts/src/verifier.cairo
# 3. Rebuild and redeploy with Groth16Verifier instead of MockVerifier
cd ../contracts && scarb build
```
